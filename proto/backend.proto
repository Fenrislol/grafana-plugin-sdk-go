syntax = "proto3";
package grafana.plugin;

//-----------------------------------------------
// Common
//-----------------------------------------------

message PluginConfig {
  int64 id = 1;
  int64 orgId = 2;
  string name = 3;
  string type = 4;
  string url = 5;
  string jsonData = 6;
  map<string,string> decryptedSecureJsonData = 7;
}

//-----------------------------------------------
// Plugin Status Check
//-----------------------------------------------

message PluginStatusRequest {
  // Plugin Configuration
  PluginConfig config = 1;

  // Environment info
  map<string,string> headers = 2;

  // Get an OpenAPI description (viewer+)
  bool fetchApi = 3;

  // appended to the grafana /metrics endpoint
  bool fetchMetrics = 4;

  // Get debug info (admin+)
  bool fetchDebug = 5;
}

message PluginStatusResponse {
  enum PluginStatus {
    UNKNOWN = 0; // starting etc
    OK = 1;
    ERROR = 2;
  }

  PluginStatus status = 1;
  string api = 2;
  string metrics = 3;
  string debug = 3;
}


//-----------------------------------------------
// QUERY
//-----------------------------------------------

message TimeRange {
  string fromRaw = 1;
  string toRaw = 2;
  int64 fromEpochMs = 3;
  int64 toEpochMs = 4;
}

message DataQuery {
  string refId = 1;
  int64 maxDataPoints = 2;
  int64 intervalMs = 3;
  TimeRange timeRange = 4; // NOTE: this moved from QueryRequest in v1
  string json = 5; // Arbitrary structure (model?  modelJson in v1)
}

message QueryRequest {
  // Plugin Configuration
  PluginConfig config = 1;

  // Environment info
  map<string,string> headers = 2;

  // List of queries
  repeated DataQuery queries = 3;
}

message QueryResponse {
  // Arrow encoded DataFrames
  // Each frame encodes its own: Errors, meta, and refId
  repeated bytes data = 1;

  // Additional response metadata
  map<string,string> headers = 2;
}


//-----------------------------------------------
// HTTP style request
//-----------------------------------------------

message PluginRequest {
  // Plugin Configuration
  PluginConfig config = 1;

  // Environment info
  map<string,string> headers = 2;

  // HTTP Style parameters
  string method = 3; // GET/POST/DELETE/etc
  string path = 4;   // (with params?)
  bytes body = 5;    // assume string unless header says otherwise?
}

message PluginResponse {
  int32 code = 1;  // Match HTTP status codes
  bytes body = 2;
  map<string,string> headers = 3;
}



//-----------------------------------------------
// All Backend Plugins Implement
//-----------------------------------------------

service BackendPlugin {
  // Get the plugin status
  rpc Check(PluginStatusRequest) returns (PluginStatusResponse);

  // HTTP Style request
  rpc Request(PluginRequest) returns (PluginResponse);

  // Well typed query interface
  rpc Query(QueryRequest) returns (QueryResponse);

  // TODO -- currently queries die when the response >4mb...
  // We need a better solution...
  // a) encode paging info in the DataFrame metadata?
  // b) chunk the results and grafana backend would
}


//-----------------------------------------------
// Allow plugins to access other plugins
// Only allow this for some plugins?  GEL only
//
// ???? How does the backend know the PluginConfig????
//-----------------------------------------------

service GrafanaPlatform {
  rpc PlatformPluginRequest(PluginRequest) returns (PluginResponse);

  rpc PlatformPluginQuery(QueryRequest) returns (QueryResponse);
}


//-----------------------------------------------------------------
// Streaming support aimed to support similar features to STOMP
// consider Apache Flight for more complex/standard
//-----------------------------------------------------------------

message StreamingRequest {
  int64 pluginId = 1; // match the id from connect request (app or datasource)

  // Environment info
  map<string,string> headers = 1;

  // The topic we are talking to
  string topic = 2;

  // The message
  string body = 3;

  // Flag if the user is already listening
  boolean subscribed = 4;
}

message StreamingMessage {
  int64 pluginId = 1;
  string topic = 2; // will be broadcast to eveyone listening to this app|ds + topic
  string message = 3; // JSON Blob
}

service StreamingPlugin {
  // Called by grafana before the first request
  // Grafana server will set up a websocket that will broadcast to all listeners
  rpc Connect(PluginConfig) returns (stream StreamingMessage);

  // If the message is not empty, send that to the user
  // throwing an error will make sure the user is not subscribed
  rpc Process(StreamingRequest) returns (StreamingMessage)

  // Stop streaming to that instance, returns the number of open connections
  rpc Disconnect(int64) returns (int64);
}


//-----------------------------------------------------------------
// Renderer (do we want this definition here?)
// OR -- can we do this via Request(PluginRequest)???
//-----------------------------------------------------------------

message RenderRequest {
  string url = 1;
  int32 width = 2;
  int32 height = 3;
  int32 timeout = 4;
  string timezone = 5;
  string encoding = 6;
  string filePath = 7;
  string renderKey = 8;
  string domain = 9;
  bool debug = 10;
}

message RenderResponse {
  string error = 1;
}

service Renderer {
  rpc Render(RenderRequest) returns (RenderResponse);
}
